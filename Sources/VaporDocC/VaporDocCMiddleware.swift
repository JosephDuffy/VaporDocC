import Vapor

public struct VaporDocCMiddleware: Middleware {
    public let archivePath: URL

    private let prefix: String = "/"

    public init(archivePath: URL) {
        self.archivePath = archivePath
    }

    public func respond(to request: Request, chainingTo next: Responder) -> EventLoopFuture<Response> {
        guard let path = request.url.path.removingPercentEncoding else {
            return request.eventLoop.makeFailedFuture(Abort(.badRequest))
        }

        guard !path.contains("../") else {
            return request.eventLoop.makeFailedFuture(Abort(.forbidden))
        }

        let indexPrefixes = [
            "documentation",
            "tutorials",
        ].map { `prefix` + $0 }

        for indexPrefix in indexPrefixes where path.hasPrefix(indexPrefix) {
            return serveStaticFileRelativeToArchive("index.html", request: request)
        }

        if path == self.prefix + "data/documentation.json" {
            if FileManager.default.fileExists(atPath: archivePath.appendingPathComponent("data/documentation.json", isDirectory: true).path) {
                return serveStaticFileRelativeToArchive("data/documentation.json", request: request)
            }

            request.logger.info("\(self.prefix + "data/documentation.json") was not found, attempting to find product's JSON in /data/documentation/ directory")

            // The docs generated by Xcode 13.0 beta 1 request "/data/documentation.json" but the
            // generated archive puts this file under "/data/documentation/{product_name}.json"
            let documentationPath = archivePath.appendingPathComponent("data/documentation", isDirectory: true)
            do {
                let contents = try FileManager.default.contentsOfDirectory(atPath: documentationPath.path)
                guard let productJSON = contents.first(where: { $0.hasSuffix(".json") }) else {
                    return next.respond(to: request)
                }

                return serveStaticFileRelativeToArchive("data/documentation/\(productJSON)", request: request)
            } catch {
                return next.respond(to: request)
            }
        }

        let staticFiles = [
            "favicon.ico",
            "favicon.svg",
            "theme-settings.json",
        ].map { `prefix` + $0 }

        for staticFile in staticFiles where path == staticFile {
            return serveStaticFileRelativeToArchive(String(staticFile.dropFirst(`prefix`.count)), request: request)
        }

        let staticFilePrefixes = [
            "css",
            "js",
            "data",
            "images",
            "downloads",
            "img",
            "videos",
        ].map { `prefix` + $0 }

        for staticFilePrefix in staticFilePrefixes where path.hasPrefix(staticFilePrefix) {
            return serveStaticFileRelativeToArchive(String(path.dropFirst(`prefix`.count)), request: request)
        }

        return next.respond(to: request)
    }

    private func serveStaticFileRelativeToArchive(_ staticFilePath: String, request: Request) -> EventLoopFuture<Response> {
        let staticFilePath = archivePath.appendingPathComponent(staticFilePath, isDirectory: false)
        return request.eventLoop.makeSucceededFuture(
            request
                .fileio
                .streamFile(
                    at: staticFilePath.path
                )
        )
    }
}
